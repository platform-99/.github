name: Terraform Plan (Reusable)

on:
  workflow_call:
    inputs:
      environment_folders:
        description: 'Space-separated list of environment folder names (e.g., "1-dev 2-test 3-prod")'
        required: true
        type: string
      terraform_version:
        description: 'Terraform version to use'
        required: false
        type: string
        default: '1.14.3'
      working_directory:
        description: 'Working directory for the repository (defaults to root)'
        required: false
        type: string
        default: '.'
      skip_validation:
        description: 'Skip single environment validation (allow multiple environments)'
        required: false
        type: boolean
        default: false
      auto_format:
        description: 'Automatically format Terraform files and commit fixes'
        required: false
        type: boolean
        default: true
      comment_on_pr:
        description: 'Comment Terraform plan output on pull requests'
        required: false
        type: boolean
        default: true
      selected_environment:
        description: 'Selected environment for workflow_dispatch (optional)'
        required: false
        type: string
      configure_git_for_private_modules:
        description: 'Configure Git authentication for private Terraform modules (requires GH_APP_ID and GH_APP_PRIVATE_KEY secrets)'
        required: false
        type: boolean
        default: false
      private_module_owner:
        description: 'GitHub organization name where private Terraform modules are located (defaults to repository owner). The GitHub App must be installed on this organization.'
        required: false
        type: string
      configure_aws_credentials:
        description: 'Configure AWS credentials using OIDC (requires AWS_ROLE_ARN secret)'
        required: false
        type: boolean
        default: false
      aws_region:
        description: 'AWS region for credential configuration (default: ca-central-1)'
        required: false
        type: string
        default: 'ca-central-1'
      kv_names:
        description: 'Space-separated list of Azure Key Vault names corresponding to environment_folders (e.g., "kv-dev-wb1a2b3c4 kv-test-wb4d5e6f7g8 kv-prod-wb7h8i9j0k1"). Order must match environment_folders. If not provided, Key Vault secret injection will be skipped. Secrets in Key Vault should be named with TF-VAR- prefix (e.g., TF-VAR-db-password).'
        required: false
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      GH_APP_ID:
        description: 'GitHub App ID for authenticating to private Terraform modules (required if configure_git_for_private_modules is true)'
        required: false
      GH_APP_PRIVATE_KEY:
        description: 'GitHub App private key for authenticating to private Terraform modules (required if configure_git_for_private_modules is true)'
        required: false
      AWS_ROLE_ARN:
        description: 'AWS IAM role ARN to assume for OIDC authentication (required if configure_aws_credentials is true)'
        required: false

permissions:
  id-token: write       # Required for OIDC
  contents: write       # Required to commit formatting fixes
  pull-requests: write  # Required to comment on PRs

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT_FOLDERS: ${{ inputs.environment_folders }}
    outputs:
      environments: ${{ steps.filter.outputs.environments }}
      skip_validation: ${{ steps.check-skip-validation.outputs.skip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}
          fetch-depth: 0  # Fetch full history to access previous commits

      - name: Check if validation should be skipped
        id: check-skip-validation
        run: |
          SKIP_VALIDATION="false"
          
          # Check input parameter (handle both boolean and string)
          if [ "${{ inputs.skip_validation }}" == "true" ] || [ "${{ inputs.skip_validation }}" == true ]; then
            SKIP_VALIDATION="true"
            echo "Validation skipped via input parameter"
          fi
          
          # For pull_request, check for label (only if not already skipped)
          if [ "$SKIP_VALIDATION" != "true" ] && [ "${{ github.event_name }}" == "pull_request" ]; then
            # Check if PR has the skip validation label
            LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' 2>/dev/null || echo "")
            if echo "$LABELS" | grep -qE "(allow-multi-env|skip-env-validation)"; then
              SKIP_VALIDATION="true"
              echo "Validation skipped via PR label"
            fi
          fi
          
          echo "skip=$SKIP_VALIDATION" >> $GITHUB_OUTPUT
          echo "Skip validation: $SKIP_VALIDATION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect modified environments
        id: filter
        run: |
          ENVIRONMENTS=""
          
          # If selected_environment is provided (workflow_dispatch), use it
          if [ -n "${{ inputs.selected_environment }}" ]; then
            ENVIRONMENTS="${{ inputs.selected_environment }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # For pull_request events, use PR base and head
            BASE_REF="${{ github.event.pull_request.base.sha }}"
            HEAD_REF="${{ github.event.pull_request.head.sha }}"
            
            # Validate that both refs are available
            if [ -z "$BASE_REF" ] || [ -z "$HEAD_REF" ]; then
              echo "Warning: Base or head SHA not available, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
            else
              # Get list of changed files
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
            fi
            
            # Check which environment folders have changes
            for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
              if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
              fi
            done
          elif [ "${{ github.event_name }}" == "push" ]; then
            # For push events, use github.event.before and github.sha
            BASE_REF="${{ github.event.before }}"
            HEAD_REF="${{ github.sha }}"
            
            # Validate that base ref is not the null commit
            if [ -n "$BASE_REF" ] && [ "$BASE_REF" != "0000000000000000000000000000000000000000" ]; then
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
            else
              echo "Warning: Base ref is null commit or not available, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
            fi
            
            # Check which environment folders have changes
            for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
              if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
              fi
            done
          else
            # For other events (workflow_dispatch without selected_environment), try to detect from git history
            if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
              BASE_REF="HEAD~1"
              HEAD_REF="HEAD"
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
              
              for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
                if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                  ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
                fi
              done
            else
              # If no previous commit exists, check all files in current commit
              echo "No previous commit found, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
              
              for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
                if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                  ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
                fi
              done
            fi
          fi
          
          # Remove leading space and convert to JSON array
          ENVIRONMENTS=$(echo "$ENVIRONMENTS" | xargs)
          if [ -z "$ENVIRONMENTS" ]; then
            ENVIRONMENTS="[]"
          else
            # Convert space-separated list to JSON array
            ENVIRONMENTS_ARRAY=""
            for env in $ENVIRONMENTS; do
              if [ -z "$ENVIRONMENTS_ARRAY" ]; then
                ENVIRONMENTS_ARRAY="\"$env\""
              else
                ENVIRONMENTS_ARRAY="$ENVIRONMENTS_ARRAY,\"$env\""
              fi
            done
            ENVIRONMENTS="[$ENVIRONMENTS_ARRAY]"
          fi
          
          echo "environments=$ENVIRONMENTS" >> $GITHUB_OUTPUT
          echo "Detected environments: $ENVIRONMENTS"

      - name: Validate single environment (PR only)
        if: github.event_name == 'pull_request' && steps.check-skip-validation.outputs.skip != 'true'
        run: |
          ENVIRONMENTS="${{ steps.filter.outputs.environments }}"
          
          # Handle empty array case
          if [ "$ENVIRONMENTS" = "[]" ]; then
            echo "‚ö†Ô∏è  Warning: No environment changes detected"
            exit 0
          fi
          
          # Count environment names in the JSON array
          # Remove brackets and quotes, then count words
          ENV_LIST=$(echo "$ENVIRONMENTS" | sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | sed 's/,/ /g')
          ENV_COUNT=$(echo "$ENV_LIST" | wc -w)
          
          if [ "$ENV_COUNT" -gt 1 ]; then
            echo "‚ùå Error: Multiple environments detected in this PR!"
            echo "This PR modifies: $ENVIRONMENTS"
            echo ""
            echo "Please split your changes into separate PRs, one per environment."
            echo "This ensures better code review, reduces risk, and maintains clear audit trails."
            echo ""
            echo "To skip this validation, add the label 'allow-multi-env' or 'skip-env-validation' to the PR."
            exit 1
          else
            echo "‚úÖ Single environment detected ($ENV_LIST) - validation passed"
          fi

  plan:
    needs: detect-changes
    if: needs.detect-changes.outputs.environments != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.detect-changes.outputs.environments) }}
      fail-fast: false
    name: Create a plan for ${{ matrix.environment }}
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TF_DIR: ${{ matrix.environment }}
      ARM_USE_OIDC: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: Validate GitHub App secrets
        if: inputs.configure_git_for_private_modules
        run: |
          if [ -z "${{ secrets.GH_APP_ID }}" ]; then
            echo "‚ùå Error: 'GH_APP_ID' secret is required when 'configure_git_for_private_modules' is true"
            exit 1
          fi
          if [ -z "${{ secrets.GH_APP_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: 'GH_APP_PRIVATE_KEY' secret is required when 'configure_git_for_private_modules' is true"
            exit 1
          fi
          echo "‚úÖ GitHub App secrets validated"

      - name: Generate Github App Token
        id: generate_token
        if: inputs.configure_git_for_private_modules
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ inputs.private_module_owner || github.repository_owner }}

      - name: Configure Git for Private Modules
        if: inputs.configure_git_for_private_modules && steps.generate_token.outcome == 'success' && steps.generate_token.outputs.token != ''
        run: |
          TOKEN="${{ steps.generate_token.outputs.token }}"
          MODULE_ORG="${{ inputs.private_module_owner || github.repository_owner }}"
          
          # Configure Git URL rewriting for HTTPS
          git config --global url."https://git:${TOKEN}@github.com/${MODULE_ORG}".insteadOf "https://github.com/${MODULE_ORG}"
          
          # Configure Git URL rewriting for SSH
          git config --global url."https://${TOKEN}:x-access-token@github.com/${MODULE_ORG}".insteadOf ssh://git@github.com/${MODULE_ORG}

      - name: Check Terraform Formatting
        id: fmt
        working-directory: ${{ inputs.working_directory }}
        run: terraform fmt -check -recursive
        continue-on-error: true
  
      - name: Fix Terraform Formatting
        if: steps.fmt.outcome == 'failure' && inputs.auto_format
        working-directory: ${{ inputs.working_directory }}
        run: terraform fmt -recursive

      - name: Commit Formatting Fixes
        if: steps.fmt.outcome == 'failure' && inputs.auto_format && github.event_name == 'pull_request'
        working-directory: ${{ inputs.working_directory }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git commit -m "fix: auto-format terraform files [skip ci]" || exit 0
          git push

      - name: Validate AWS credentials secret
        if: inputs.configure_aws_credentials
        run: |
          if [ -z "${{ secrets.AWS_ROLE_ARN }}" ]; then
            echo "‚ùå Error: 'AWS_ROLE_ARN' secret is required when 'configure_aws_credentials' is true"
            exit 1
          fi
          echo "‚úÖ AWS credentials secret validated"

      - name: Configure AWS credentials
        if: inputs.configure_aws_credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Terraform Init
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform init

      - name: Inject Terraform Variables from Azure Key Vault
        if: inputs.kv_names != null && inputs.kv_names != ''
        uses: ./.github/actions/azure-keyvault-inject-secrets
        with:
          environment_folders: ${{ inputs.environment_folders }}
          kv_names: ${{ inputs.kv_names }}
          current_environment: ${{ env.TF_DIR }}
          azure_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          azure_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
          azure_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Plan
        id: plan
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Terraform Plan Output
        id: plan-output
        if: steps.plan.outcome == 'success'
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        run: |
          terraform show -no-color tfplan > plan_output.txt || echo "No changes to infrastructure." > plan_output.txt

      - name: Comment PR
        if: github.event_name == 'pull_request' && steps.plan.outcome == 'success' && inputs.comment_on_pr
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        run: |
          PLAN=$(cat plan_output.txt 2>/dev/null || echo "No changes to infrastructure.")
          WORKFLOW_RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Write comment body to a file to avoid "Argument list too long" error
          cat > comment_body.txt <<EOF
          ## Terraform Plan for ${{ env.TF_DIR }} üìñ
          
          <details><summary>Show Plan</summary>
          
          \`\`\`
          $PLAN
          \`\`\`
          
          </details>
          
          üìù The plan was generated in the [Github Actions Workflow Run]($WORKFLOW_RUN_URL)
          EOF
          
          gh pr comment ${{ github.event.pull_request.number }} --body-file comment_body.txt
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

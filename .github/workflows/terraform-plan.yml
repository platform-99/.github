name: Terraform Plan (Reusable)

on:
  workflow_call:
    inputs:
      environment_folders:
        description: 'Space-separated list of environment folder names (e.g., "1-dev 2-test 3-prod")'
        required: true
        type: string
      terraform_version:
        description: 'Terraform version to use'
        required: false
        type: string
        default: '1.6.0'
      working_directory:
        description: 'Working directory for the repository (defaults to root)'
        required: false
        type: string
        default: '.'
      skip_validation:
        description: 'Skip single environment validation (allow multiple environments)'
        required: false
        type: boolean
        default: false
      auto_format:
        description: 'Automatically format Terraform files and commit fixes'
        required: false
        type: boolean
        default: true
      comment_on_pr:
        description: 'Comment Terraform plan output on pull requests'
        required: false
        type: boolean
        default: true
      selected_environment:
        description: 'Selected environment for workflow_dispatch (optional)'
        required: false
        type: string
      configure_git_for_private_modules:
        description: 'Configure Git authentication for private Terraform modules (requires GH_APP_ID and GH_APP_PRIVATE_KEY secrets)'
        required: false
        type: boolean
        default: false
      configure_aws_credentials:
        description: 'Configure AWS credentials using OIDC (requires AWS_ROLE_ARN secret)'
        required: false
        type: boolean
        default: false
      aws_region:
        description: 'AWS region for credential configuration (default: ca-central-1)'
        required: false
        type: string
        default: 'ca-central-1'
      kv_names:
        description: 'Space-separated list of Azure Key Vault names corresponding to environment_folders (e.g., "kv-dev-wb1a2b3c4 kv-test-wb4d5e6f7g8 kv-prod-wb7h8i9j0k1"). Order must match environment_folders. If not provided, Key Vault secret injection will be skipped. Secrets in Key Vault should be named with TF-VAR- prefix (e.g., TF-VAR-db-password).'
        required: false
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      GH_APP_ID:
        description: 'GitHub App ID for authenticating to private Terraform modules (required if configure_git_for_private_modules is true)'
        required: false
      GH_APP_PRIVATE_KEY:
        description: 'GitHub App private key for authenticating to private Terraform modules (required if configure_git_for_private_modules is true)'
        required: false
      AWS_ROLE_ARN:
        description: 'AWS IAM role ARN to assume for OIDC authentication (required if configure_aws_credentials is true)'
        required: false

permissions:
  id-token: write       # Required for OIDC
  contents: write       # Required to commit formatting fixes
  pull-requests: write  # Required to comment on PRs

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT_FOLDERS: ${{ inputs.environment_folders }}
    outputs:
      environments: ${{ steps.filter.outputs.environments }}
      skip_validation: ${{ steps.check-skip-validation.outputs.skip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}
          fetch-depth: 0  # Fetch full history to access previous commits

      - name: Check if validation should be skipped
        id: check-skip-validation
        run: |
          SKIP_VALIDATION="false"
          
          # Check input parameter (handle both boolean and string)
          if [ "${{ inputs.skip_validation }}" == "true" ] || [ "${{ inputs.skip_validation }}" == true ]; then
            SKIP_VALIDATION="true"
            echo "Validation skipped via input parameter"
          fi
          
          # For pull_request, check for label (only if not already skipped)
          if [ "$SKIP_VALIDATION" != "true" ] && [ "${{ github.event_name }}" == "pull_request" ]; then
            # Check if PR has the skip validation label
            LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' 2>/dev/null || echo "")
            if echo "$LABELS" | grep -qE "(allow-multi-env|skip-env-validation)"; then
              SKIP_VALIDATION="true"
              echo "Validation skipped via PR label"
            fi
          fi
          
          echo "skip=$SKIP_VALIDATION" >> $GITHUB_OUTPUT
          echo "Skip validation: $SKIP_VALIDATION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect modified environments
        id: filter
        run: |
          ENVIRONMENTS=""
          
          # If selected_environment is provided (workflow_dispatch), use it
          if [ -n "${{ inputs.selected_environment }}" ]; then
            ENVIRONMENTS="${{ inputs.selected_environment }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # For pull_request events, use PR base and head
            BASE_REF="${{ github.event.pull_request.base.sha }}"
            HEAD_REF="${{ github.event.pull_request.head.sha }}"
            
            # Validate that both refs are available
            if [ -z "$BASE_REF" ] || [ -z "$HEAD_REF" ]; then
              echo "Warning: Base or head SHA not available, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
            else
              # Get list of changed files
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
            fi
            
            # Check which environment folders have changes
            for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
              if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
              fi
            done
          elif [ "${{ github.event_name }}" == "push" ]; then
            # For push events, use github.event.before and github.sha
            BASE_REF="${{ github.event.before }}"
            HEAD_REF="${{ github.sha }}"
            
            # Validate that base ref is not the null commit
            if [ -n "$BASE_REF" ] && [ "$BASE_REF" != "0000000000000000000000000000000000000000" ]; then
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
            else
              echo "Warning: Base ref is null commit or not available, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
            fi
            
            # Check which environment folders have changes
            for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
              if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
              fi
            done
          else
            # For other events (workflow_dispatch without selected_environment), try to detect from git history
            if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
              BASE_REF="HEAD~1"
              HEAD_REF="HEAD"
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
              
              for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
                if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                  ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
                fi
              done
            else
              # If no previous commit exists, check all files in current commit
              echo "No previous commit found, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
              
              for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
                if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                  ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
                fi
              done
            fi
          fi
          
          # Remove leading space and convert to JSON array
          ENVIRONMENTS=$(echo "$ENVIRONMENTS" | xargs)
          if [ -z "$ENVIRONMENTS" ]; then
            ENVIRONMENTS="[]"
          else
            # Convert space-separated list to JSON array
            ENVIRONMENTS_ARRAY=""
            for env in $ENVIRONMENTS; do
              if [ -z "$ENVIRONMENTS_ARRAY" ]; then
                ENVIRONMENTS_ARRAY="\"$env\""
              else
                ENVIRONMENTS_ARRAY="$ENVIRONMENTS_ARRAY,\"$env\""
              fi
            done
            ENVIRONMENTS="[$ENVIRONMENTS_ARRAY]"
          fi
          
          echo "environments=$ENVIRONMENTS" >> $GITHUB_OUTPUT
          echo "Detected environments: $ENVIRONMENTS"

      - name: Validate single environment (PR only)
        if: github.event_name == 'pull_request' && steps.check-skip-validation.outputs.skip != 'true'
        run: |
          ENVIRONMENTS="${{ steps.filter.outputs.environments }}"
          
          # Handle empty array case
          if [ "$ENVIRONMENTS" = "[]" ]; then
            echo "‚ö†Ô∏è  Warning: No environment changes detected"
            exit 0
          fi
          
          # Count environment names in the JSON array
          # Remove brackets and quotes, then count words
          ENV_LIST=$(echo "$ENVIRONMENTS" | sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | sed 's/,/ /g')
          ENV_COUNT=$(echo "$ENV_LIST" | wc -w)
          
          if [ "$ENV_COUNT" -gt 1 ]; then
            echo "‚ùå Error: Multiple environments detected in this PR!"
            echo "This PR modifies: $ENVIRONMENTS"
            echo ""
            echo "Please split your changes into separate PRs, one per environment."
            echo "This ensures better code review, reduces risk, and maintains clear audit trails."
            echo ""
            echo "To skip this validation, add the label 'allow-multi-env' or 'skip-env-validation' to the PR."
            exit 1
          else
            echo "‚úÖ Single environment detected ($ENV_LIST) - validation passed"
          fi

  plan:
    needs: detect-changes
    if: needs.detect-changes.outputs.environments != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.detect-changes.outputs.environments) }}
      fail-fast: false
    name: Create a plan for ${{ matrix.environment }}
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TF_DIR: ${{ matrix.environment }}
      ARM_USE_OIDC: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.head.sha || github.head_ref || github.ref }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: Check Terraform Formatting
        id: fmt
        working-directory: ${{ inputs.working_directory }}
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Fix Terraform Formatting
        if: steps.fmt.outcome == 'failure' && inputs.auto_format
        working-directory: ${{ inputs.working_directory }}
        run: terraform fmt -recursive

      - name: Validate GitHub App secrets
        if: inputs.configure_git_for_private_modules
        run: |
          if [ -z "${{ secrets.GH_APP_ID }}" ]; then
            echo "‚ùå Error: 'GH_APP_ID' secret is required when 'configure_git_for_private_modules' is true"
            exit 1
          fi
          if [ -z "${{ secrets.GH_APP_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: 'GH_APP_PRIVATE_KEY' secret is required when 'configure_git_for_private_modules' is true"
            exit 1
          fi
          echo "‚úÖ GitHub App secrets validated"

      - name: Generate Github App Token
        id: generate_token
        if: inputs.configure_git_for_private_modules
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      # Configure Git ONLY if a token was generated
      - name: Configure Git for Private Modules
        if: inputs.configure_git_for_private_modules && steps.generate_token.outcome == 'success' && steps.generate_token.outputs.token != ''
        run: |
          TOKEN="${{ steps.generate_token.outputs.token }}"
          
          # Create GIT_ASKPASS script
          cat > /tmp/git-askpass.sh << 'EOF'
          #!/bin/sh
          echo "$GITHUB_TOKEN"
          EOF
          chmod +x /tmp/git-askpass.sh
          
          # Configure Git URL rewriting for HTTPS
          git config --global url."https://x-access-token:${TOKEN}@github.com/".insteadOf "https://github.com/"
          
          # Also configure for SSH-style URLs that Terraform might use
          git config --global url."https://x-access-token:${TOKEN}@github.com/".insteadOf "git@github.com:"
          
          # Set up credential helper to use the token
          mkdir -p ~/.git
          echo "https://x-access-token:${TOKEN}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          git config --global credential.helper store
          
          # Set username for GitHub
          git config --global credential.https://github.com.username x-access-token
          
          # Export token as environment variable for GIT_ASKPASS and Terraform
          echo "GITHUB_TOKEN=${TOKEN}" >> $GITHUB_ENV
          echo "GIT_ASKPASS=/tmp/git-askpass.sh" >> $GITHUB_ENV
          echo "GIT_TERMINAL_PROMPT=0" >> $GITHUB_ENV
          
          # Verify the configuration
          echo "‚úÖ Git configured for private modules"
          echo "Git config:"
          git config --global --get-regexp url
          git config --global --get-regexp credential
          echo ""
          echo "Testing Git authentication..."
          if git ls-remote https://github.com/${{ github.repository }}.git HEAD > /dev/null 2>&1; then
            echo "‚úÖ Git authentication verified"
          else
            echo "‚ö†Ô∏è  Warning: Git authentication test failed"
            echo "Token length: ${#TOKEN} characters"
          fi

      - name: Commit Formatting Fixes
        if: steps.fmt.outcome == 'failure' && inputs.auto_format && github.event_name == 'pull_request'
        working-directory: ${{ inputs.working_directory }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git commit -m "fix: auto-format terraform files [skip ci]" || exit 0
          git push

      - name: Validate AWS credentials secret
        if: inputs.configure_aws_credentials
        run: |
          if [ -z "${{ secrets.AWS_ROLE_ARN }}" ]; then
            echo "‚ùå Error: 'AWS_ROLE_ARN' secret is required when 'configure_aws_credentials' is true"
            exit 1
          fi
          echo "‚úÖ AWS credentials secret validated"

      - name: Configure AWS credentials
        if: inputs.configure_aws_credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Terraform Init
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          GITHUB_TOKEN: ${{ inputs.configure_git_for_private_modules && steps.generate_token.outputs.token || '' }}
          GIT_ASKPASS: ${{ inputs.configure_git_for_private_modules && '/tmp/git-askpass.sh' || '' }}
          GIT_TERMINAL_PROMPT: ${{ inputs.configure_git_for_private_modules && '0' || '' }}
        run: |
          if [ "${{ inputs.configure_git_for_private_modules }}" == "true" ]; then
            echo "üîç Debug: Git configuration for Terraform Init"
            echo "GIT_ASKPASS: ${GIT_ASKPASS:-not set}"
            echo "GITHUB_TOKEN: ${GITHUB_TOKEN:+set (${#GITHUB_TOKEN} chars)}"
            git config --global --get-regexp url || true
            git config --global --get-regexp credential || true
          fi
          terraform init

      - name: 'Determine Key Vault Name'
        id: determine-kv-name
        shell: bash
        env:
          ENVIRONMENT_FOLDERS: ${{ inputs.environment_folders }}
          KV_NAMES: ${{ inputs.kv_names }}
        run: |
          # Get current environment folder from matrix
          ENV_FOLDER="${{ env.TF_DIR }}"
          
          if [ -z "$KV_NAMES" ]; then
            echo "‚ÑπÔ∏è  No Key Vault names provided, skipping Key Vault secret injection"
            echo "kv_name=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Convert space-separated lists to arrays
          read -a ENV_ARRAY <<< "$ENVIRONMENT_FOLDERS"
          read -a KV_ARRAY <<< "$KV_NAMES"
          
          # Find the index of current environment in the environment folders list
          ENV_INDEX=-1
          for i in "${!ENV_ARRAY[@]}"; do
            if [ "${ENV_ARRAY[$i]}" = "$ENV_FOLDER" ]; then
              ENV_INDEX=$i
              break
            fi
          done
          
          if [ $ENV_INDEX -eq -1 ]; then
            echo "‚ö†Ô∏è  Warning: Environment folder '$ENV_FOLDER' not found in environment_folders list"
            echo "‚ÑπÔ∏è  Skipping Key Vault secret injection"
            echo "kv_name=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get corresponding Key Vault name by index
          if [ $ENV_INDEX -lt ${#KV_ARRAY[@]} ]; then
            KV_NAME="${KV_ARRAY[$ENV_INDEX]}"
            echo "‚úÖ Matched environment '$ENV_FOLDER' (index $ENV_INDEX) to Key Vault: $KV_NAME"
          else
            echo "‚ö†Ô∏è  Warning: No Key Vault name found at index $ENV_INDEX for environment '$ENV_FOLDER'"
            echo "‚ÑπÔ∏è  Key Vault names list has ${#KV_ARRAY[@]} entries, but environment is at index $ENV_INDEX"
            echo "‚ÑπÔ∏è  Skipping Key Vault secret injection"
            echo "kv_name=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "kv_name=$KV_NAME" >> $GITHUB_OUTPUT
          echo "üîç Using Key Vault: $KV_NAME"

      - name: Azure Login (OIDC)
        if: steps.determine-kv-name.outputs.kv_name != ''
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: 'Fetch and Inject TF_VARS from Azure Key Vault'
        if: steps.determine-kv-name.outputs.kv_name != ''
        shell: bash
        env:
          KV_NAME: ${{ steps.determine-kv-name.outputs.kv_name }}
        run: |
          # Azure CLI is pre-installed on ubuntu-latest runners
          # Verify Azure CLI is available
          if ! command -v az &> /dev/null; then
            echo "‚ùå Error: Azure CLI (az) is not available"
            exit 1
          fi
          
          # 1. Verify Key Vault exists and is accessible
          echo "üîç Checking if Key Vault exists: $KV_NAME"
          if ! az keyvault show --name "$KV_NAME" >/dev/null 2>&1; then
            echo "‚ùå Error: Key Vault '$KV_NAME' not found or not accessible"
            echo "Please verify the Key Vault name is correct and the service principal has access."
            exit 1
          fi
          
          # 2. Get a list of all secret names from the vault
          echo "üîç Searching for TF-VAR secrets in Key Vault: $KV_NAME"
          SECRET_NAMES=$(az keyvault secret list --vault-name "$KV_NAME" --query "[].name" -o tsv 2>/dev/null || echo "")
          
          if [ -z "$SECRET_NAMES" ]; then
            echo "‚ÑπÔ∏è  No secrets found in Key Vault or Key Vault not accessible"
            exit 0
          fi
          
          FOUND_COUNT=0
          for NAME in $SECRET_NAMES; do
            if [[ $NAME == TF-VAR-* ]]; then
              # 2. Get the actual secret value (preserves newlines)
              VALUE=$(az keyvault secret show --vault-name "$KV_NAME" --name "$NAME" --query "value" -o tsv 2>/dev/null || echo "")
              
              if [ -z "$VALUE" ]; then
                echo "‚ö†Ô∏è  Warning: Could not retrieve secret: $NAME"
                continue
              fi
              
              # 3. Transform name for Terraform (TF-VAR-db-pass -> TF_VAR_db_pass)
              ENV_NAME=$(echo "$NAME" | tr '-' '_')

              # 4. Register masks line-by-line for security
              # This ensures every line of a multi-line secret is redacted in logs
              while IFS= read -r line; do
                if [ -n "$line" ]; then
                  echo "::add-mask::$line"
                fi
              done <<< "$VALUE"

              # 5. Simplified Heredoc Injection
              # The { } block opens GITHUB_ENV once for all lines in the block
              {
                echo "${ENV_NAME}<<SECRET_EOF"
                echo "$VALUE"
                echo "SECRET_EOF"
              } >> "$GITHUB_ENV"
              
              echo "‚úÖ Injected $ENV_NAME (from Key Vault secret: $NAME)"
              FOUND_COUNT=$((FOUND_COUNT + 1))
            fi
          done
          
          if [ $FOUND_COUNT -eq 0 ]; then
            echo "‚ÑπÔ∏è  No secrets found with TF-VAR- prefix in Key Vault"
          else
            echo "‚úÖ Successfully injected $FOUND_COUNT Terraform variable(s) from Key Vault"
          fi

      - name: Terraform Plan
        id: plan
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Terraform Plan Output
        id: plan-output
        if: steps.plan.outcome == 'success'
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        run: |
          terraform show -no-color tfplan > plan_output.txt || echo "No changes to infrastructure." > plan_output.txt

      - name: Comment PR
        if: github.event_name == 'pull_request' && steps.plan.outcome == 'success' && inputs.comment_on_pr
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        run: |
          PLAN=$(cat plan_output.txt 2>/dev/null || echo "No changes to infrastructure.")
          WORKFLOW_RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          gh pr comment ${{ github.event.pull_request.number }} --body "## Terraform Plan for ${{ env.TF_DIR }} üìñ
          
          <details><summary>Show Plan</summary>
          
          \`\`\`
          $PLAN
          \`\`\`
          
          </details>
          
          üìù The plan was generated in the [Github Actions Workflow Run]($WORKFLOW_RUN_URL)"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

name: Terraform Apply (Reusable)

on:
  workflow_call:
    inputs:
      environment_folders:
        description: 'Space-separated list of environment folder names (e.g., "1-dev 2-test 3-prod")'
        required: true
        type: string
      terraform_version:
        description: 'Terraform version to use'
        required: false
        type: string
        default: '1.6.0'
      working_directory:
        description: 'Working directory for the repository (defaults to root)'
        required: false
        type: string
        default: '.'
      base_ref:
        description: 'Base ref for change detection (for push events, use github.event.before)'
        required: false
        type: string
      head_ref:
        description: 'Head ref for change detection (for push events, use github.sha)'
        required: false
        type: string
      selected_environment:
        description: 'Selected environment for workflow_dispatch (optional)'
        required: false
        type: string
      kv_names:
        description: 'Space-separated list of Azure Key Vault names corresponding to environment_folders (e.g., "kv-dev-wb1a2b3c4 kv-test-wb4d5e6f7g8 kv-prod-wb7h8i9j0k1"). Order must match environment_folders. If not provided, Key Vault secret injection will be skipped. Secrets in Key Vault should be named with TF-VAR- prefix (e.g., TF-VAR-db-password).'
        required: false
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true

permissions:
  id-token: write  # Required for OIDC
  contents: read   # Required to read the repository contents

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT_FOLDERS: ${{ inputs.environment_folders }}
    outputs:
      environments: ${{ steps.filter.outputs.environments }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history to access previous commits

      - name: Detect modified environments
        id: filter
        run: |
          ENVIRONMENTS=""
          
          # If selected_environment is provided (workflow_dispatch), use it
          if [ -n "${{ inputs.selected_environment }}" ]; then
            ENVIRONMENTS="${{ inputs.selected_environment }}"
          elif [ "${{ github.event_name }}" == "push" ]; then
            # For push events, use github.event.before and github.sha
            BASE_REF="${{ github.event.before }}"
            HEAD_REF="${{ github.sha }}"
            
            # Validate that base ref is not the null commit
            if [ -n "$BASE_REF" ] && [ "$BASE_REF" != "0000000000000000000000000000000000000000" ]; then
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
            else
              echo "Warning: Base ref is null commit or not available, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
            fi
            
            # Check which environment folders have changes
            for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
              if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
              fi
            done
          else
            # For other events (workflow_dispatch without selected_environment), try to detect from git history
            if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
              BASE_REF="HEAD~1"
              HEAD_REF="HEAD"
              CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF 2>/dev/null || echo "")
              
              for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
                if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                  ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
                fi
              done
            else
              # If no previous commit exists, check all files in current commit
              echo "No previous commit found, checking all files in current commit"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD || echo "")
              
              for ENV_FOLDER in $ENVIRONMENT_FOLDERS; do
                if echo "$CHANGED_FILES" | grep -q "^${ENV_FOLDER}/"; then
                  ENVIRONMENTS="$ENVIRONMENTS $ENV_FOLDER"
                fi
              done
            fi
          fi
          
          # Remove leading space and convert to JSON array
          ENVIRONMENTS=$(echo "$ENVIRONMENTS" | xargs)
          if [ -z "$ENVIRONMENTS" ]; then
            ENVIRONMENTS="[]"
          else
            # Convert space-separated list to JSON array
            ENVIRONMENTS_ARRAY=""
            for env in $ENVIRONMENTS; do
              if [ -z "$ENVIRONMENTS_ARRAY" ]; then
                ENVIRONMENTS_ARRAY="\"$env\""
              else
                ENVIRONMENTS_ARRAY="$ENVIRONMENTS_ARRAY,\"$env\""
              fi
            done
            ENVIRONMENTS="[$ENVIRONMENTS_ARRAY]"
          fi
          
          echo "environments=$ENVIRONMENTS" >> $GITHUB_OUTPUT
          echo "Detected environments: $ENVIRONMENTS"

  apply:
    needs: detect-changes
    if: needs.detect-changes.outputs.environments != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.detect-changes.outputs.environments) }}
      fail-fast: false
    name: Apply terraform configuration for ${{ matrix.environment }}
    env:
      TF_DIR: ${{ matrix.environment }}
      ARM_USE_OIDC: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: 'Determine Key Vault Name'
        id: determine-kv-name
        shell: bash
        env:
          ENVIRONMENT_FOLDERS: ${{ inputs.environment_folders }}
          KV_NAMES: ${{ inputs.kv_names }}
        run: |
          # Get current environment folder from matrix
          ENV_FOLDER="${{ env.TF_DIR }}"
          
          if [ -z "$KV_NAMES" ]; then
            echo "‚ÑπÔ∏è  No Key Vault names provided, skipping Key Vault secret injection"
            echo "kv_name=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Convert space-separated lists to arrays
          read -a ENV_ARRAY <<< "$ENVIRONMENT_FOLDERS"
          read -a KV_ARRAY <<< "$KV_NAMES"
          
          # Find the index of current environment in the environment folders list
          ENV_INDEX=-1
          for i in "${!ENV_ARRAY[@]}"; do
            if [ "${ENV_ARRAY[$i]}" = "$ENV_FOLDER" ]; then
              ENV_INDEX=$i
              break
            fi
          done
          
          if [ $ENV_INDEX -eq -1 ]; then
            echo "‚ö†Ô∏è  Warning: Environment folder '$ENV_FOLDER' not found in environment_folders list"
            echo "‚ÑπÔ∏è  Skipping Key Vault secret injection"
            echo "kv_name=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get corresponding Key Vault name by index
          if [ $ENV_INDEX -lt ${#KV_ARRAY[@]} ]; then
            KV_NAME="${KV_ARRAY[$ENV_INDEX]}"
            echo "‚úÖ Matched environment '$ENV_FOLDER' (index $ENV_INDEX) to Key Vault: $KV_NAME"
          else
            echo "‚ö†Ô∏è  Warning: No Key Vault name found at index $ENV_INDEX for environment '$ENV_FOLDER'"
            echo "‚ÑπÔ∏è  Key Vault names list has ${#KV_ARRAY[@]} entries, but environment is at index $ENV_INDEX"
            echo "‚ÑπÔ∏è  Skipping Key Vault secret injection"
            echo "kv_name=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "kv_name=$KV_NAME" >> $GITHUB_OUTPUT
          echo "üîç Using Key Vault: $KV_NAME"

      - name: Azure Login (OIDC)
        if: steps.determine-kv-name.outputs.kv_name != ''
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: 'Fetch and Inject TF_VARS from Azure Key Vault'
        if: steps.determine-kv-name.outputs.kv_name != ''
        shell: bash
        env:
          KV_NAME: ${{ steps.determine-kv-name.outputs.kv_name }}
        run: |
          # Azure CLI is pre-installed on ubuntu-latest runners
          # Verify Azure CLI is available
          if ! command -v az &> /dev/null; then
            echo "‚ùå Error: Azure CLI (az) is not available"
            exit 1
          fi
          
          # 1. Verify Key Vault exists and is accessible
          echo "üîç Checking if Key Vault exists: $KV_NAME"
          if ! az keyvault show --name "$KV_NAME" >/dev/null 2>&1; then
            echo "‚ùå Error: Key Vault '$KV_NAME' not found or not accessible"
            echo "Please verify the Key Vault name is correct and the service principal has access."
            exit 1
          fi
          
          # 2. Get a list of all secret names from the vault
          echo "üîç Searching for TF-VAR secrets in Key Vault: $KV_NAME"
          SECRET_NAMES=$(az keyvault secret list --vault-name "$KV_NAME" --query "[].name" -o tsv 2>/dev/null || echo "")
          
          if [ -z "$SECRET_NAMES" ]; then
            echo "‚ÑπÔ∏è  No secrets found in Key Vault or Key Vault not accessible"
            exit 0
          fi
          
          FOUND_COUNT=0
          for NAME in $SECRET_NAMES; do
            if [[ $NAME == TF-VAR-* ]]; then
              # 2. Get the actual secret value (preserves newlines)
              VALUE=$(az keyvault secret show --vault-name "$KV_NAME" --name "$NAME" --query "value" -o tsv 2>/dev/null || echo "")
              
              if [ -z "$VALUE" ]; then
                echo "‚ö†Ô∏è  Warning: Could not retrieve secret: $NAME"
                continue
              fi
              
              # 3. Transform name for Terraform (TF-VAR-db-pass -> TF_VAR_db_pass)
              ENV_NAME=$(echo "$NAME" | tr '-' '_')

              # 4. Register masks line-by-line for security
              # This ensures every line of a multi-line secret is redacted in logs
              while IFS= read -r line; do
                if [ -n "$line" ]; then
                  echo "::add-mask::$line"
                fi
              done <<< "$VALUE"

              # 5. Simplified Heredoc Injection
              # The { } block opens GITHUB_ENV once for all lines in the block
              {
                echo "${ENV_NAME}<<SECRET_EOF"
                echo "$VALUE"
                echo "SECRET_EOF"
              } >> "$GITHUB_ENV"
              
              echo "‚úÖ Injected $ENV_NAME (from Key Vault secret: $NAME)"
              FOUND_COUNT=$((FOUND_COUNT + 1))
            fi
          done
          
          if [ $FOUND_COUNT -eq 0 ]; then
            echo "‚ÑπÔ∏è  No secrets found with TF-VAR- prefix in Key Vault"
          else
            echo "‚úÖ Successfully injected $FOUND_COUNT Terraform variable(s) from Key Vault"
          fi

      - name: Terraform Init
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform init

      - name: Terraform Apply
        working-directory: ${{ inputs.working_directory }}/${{ env.TF_DIR }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform apply -auto-approve -no-color
